#ifndef EventReader_h
#define EventReader_h

/** geant 4 libs **/
#include "G4VPrimaryGenerator.hh"

/** ROOT libs **/
#include "TFile.h"
#include "TTree.h"

/** standard libs **/
#include <string>
#include <vector>

#include "GaugiKernel/MsgStream.h"
#include "GaugiKernel/macros.h"
//#include "EventInfo/EventInfo.h"
//#include "EventInfo/EventInfoContainer.h"
//#include "TruthParticle/TruthParticle.h"
//#include "TruthParticle/TruthParticleContainer.h"





class EventReaderMessenger;

class EventReader : public G4VPrimaryGenerator, public MsgService 
{
   
  public:
    /** Constructor **/
    EventReader();
    /** Destructor **/
    virtual ~EventReader();
    
    void Initialize();
    // The default behavior is that a single HepMC event generated by
    // GenerateHepMCEvent() will be converted to G4Event through HepMC2G4().
    virtual void GeneratePrimaryVertex(G4Event* anEvent);

    /** File name to read all pythia events **/
    PRIMITIVE_SETTER_AND_GETTER( std::string , m_filename, SetFileName, GetFileName );
    /** verbosete level **/
    PRIMITIVE_SETTER_AND_GETTER( int , m_verbose, SetVerboseLevel, GetVerboseLevel );

    
  private:
    
    template <class T> void InitBranch(TTree* fChain, std::string branch_name, T* param, bool message=true);
    
    void link(TTree *t);
    void clear();
    void allocate();
    void release();

    // We  have to take care for the position of primaries because
    // primary vertices outside the world voulme give rise to G4Execption.
    // If the default implementation is not adequate, an alternative
    // can be implemented in your own class.
    bool CheckVertexInsideWorld(const G4ThreeVector& pos) const;
    
    //void Load( G4Event *, xAOD::EventInfo *);

    //bool Add( G4Event* g4event , int i, int bc_id );

    unsigned int           m_evt;
    std::string            m_filename;
    std::string            m_outputEventKey;
    int                    m_verbose;
    EventReaderMessenger  *m_messenger;

    TFile *m_f;
    TTree *m_ttree;

    double m_avgmu;

    std::vector<int>    *m_p_isMain		  ;
    std::vector<int>    *m_p_pdg_id	    ;
    std::vector<int>    *m_p_bc_id	    ;
    std::vector<float>  *m_bc_mu				;
    std::vector<int>    *m_bc_id_nhits  ;	
    std::vector<float>  *m_p_px				  ;
    std::vector<float>  *m_p_py         ;
    std::vector<float>  *m_p_pz		      ;
    std::vector<float>  *m_p_prod_x		  ;
    std::vector<float>  *m_p_prod_y		  ;
    std::vector<float>  *m_p_prod_z		  ;
    std::vector<float>  *m_p_prod_t		  ;
    std::vector<float>  *m_p_eta		    ;
    std::vector<float>  *m_p_phi		    ;
    std::vector<float>  *m_p_e		      ;
    std::vector<float>  *m_p_et		      ;



};



#endif
