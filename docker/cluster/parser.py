#!/usr/bin/env python3


from Gaugi.messenger    import LoggingLevel, Logger
import argparse
import sys,os


mainLogger = Logger.getModuleLogger("Parser")
parser = argparse.ArgumentParser(description = '', add_help = False)
parser = argparse.ArgumentParser()

parser.add_argument('-v','--volume', action='store', dest='volume', required = True,
                    help = "The place where all files will be stored.")



parser.add_argument('-o','--outputFile', action='store', dest='outputFile', required = True,
                    help = "The event file generated by the reconstruction framework.")

parser.add_argument('-f','--filter', action='store', dest='filter', required = True,
                    help = "The event filter (Zee, JF17 or MB).")

parser.add_argument('-e','--evt','--numberOfEventsPerJob', action='store', dest='numberOfEventsPerJob', required = True, type=int, default=1,
                    help = "The number of events per job to be generated.")

parser.add_argument('-j','--numberOfJobs', action='store', dest='njobs', required = True, type=int, default=1,
                    help = "The number of jobs in the pythia generation step. The number of total events will be the number of events (--evt) times the number of jobs.")

parser.add_argument('--pileupAvg', action='store', dest='pileupAvg', required = False, type=int, default=0,
                    help = "The pileup average (default is zero).")

parser.add_argument('--bc_id_start', action='store', dest='bc_id_start', required = False, type=int, default=-24,
                    help = "The bunch crossing id start.")

parser.add_argument('--bc_id_end', action='store', dest='bc_id_end', required = False, type=int, default=7,
                    help = "The bunch crossing id end.")

parser.add_argument('--bc_duration', action='store', dest='bc_duration', required = False, type=int, default=25,
                    help = "The bunch crossing duration (in nanoseconds).")

parser.add_argument('--outputLevel', action='store', dest='outputLevel', required = False, type=int, default=6,
                    help = "The output level messenger.")

parser.add_argument('-s','--seed', action='store', dest='seed', required = False, type=int, default=0,
                    help = "The pythia seed (zero is the clock system)")

parser.add_argument('-r','--reco_script', action='store', dest='reco_script', required = False , default='reco_trf.py',
                    help = "The reconstruction script used into the reco step. This script should be in lorenzett/scripts directory")

parser.add_argument('-n','--ntuple', action='store', dest='ntuple', required = False , default='physics',
                    help = "The ntuple schemma. Choose between physics or raw (for energy reconstruction studies).")




def cmd( f, command ):
  print(command)
  f.write(command+'\n')


if len(sys.argv)==1:
  parser.print_help()
  sys.exit(1)

args = parser.parse_args()

# Get the number of cpus
import multiprocessing
ncpu = multiprocessing.cpu_count()


# Where this files will be store?
volume = args.volume


f = open(volume+'/command.sh', 'w')

# Create the lorenzetti and setup it into the volume
cmd( f,  'source /setup_here.sh %s' % volume )

# generate the pythia file into the volume
output = volume + '/' + args.outputFile + '.temp'


# Discovery witch script will be used
package = args.filter.split('/')[0]
script = args.filter.split('/')[1]
script = volume+'/lorenzetti/generator/' + package + '/share/' + script


# Prepare the pythia command
command = "python {SCRIPT} \
-s {SEED} \
--bc_id_start {BCID_START} \
--bc_id_end {BCID_END} \
--pileupAvg {AVGMU} \
--evt {NEVENTS}".format(  SCRIPT      = script,
                          SEED        = args.seed,
                          BCID_START  = args.bc_id_start,
                          BCID_END    = args.bc_id_end,
                          AVGMU       = args.pileupAvg,
                          NEVENTS     = args.numberOfEventsPerJob)


# Prepare the geant command
command = "python {VOLUME}/lorenzetti/scripts/prun_job.py -o {OUTPUT} -c '{COMMAND}' -mt {NTHREADS} -n {NJOBS}".format( VOLUME=volume,
                                                                                                                    COMMAND=command,
                                                                                                                    NTHREADS=ncpu,
                                                                                                                    NJOBS=args.njobs,
                                                                                                                    OUTPUT=output)

# Run it!
cmd( f, command )



input  = output
output = volume+'/'+args.outputFile


reco_script = args.reco_script
command = 'python '+volume+'/lorenzetti/scripts/' + reco_script + ' -i {INPUT} -o {OUTPUT} -nt {NTHREADS} --ntuple {NTUPLE}'.format( INPUT     = input,
                                                                                                                                      OUTPUT    = output,
                                                                                                                                      NTHREADS  = ncpu,
                                                                                                                                      NTUPLE    = args.ntuple)

cmd( f, command )

# Remove eveything
cmd(f, 'rm -rf %s/lorenzetti' % volume )

f.close()

os.system('source %s/command.sh'%volume )
os.system('rm %s/command.sh'%volume )



